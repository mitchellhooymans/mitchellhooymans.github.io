<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Black Hole Merger | Mitchell Hooymans</title>
    <meta name="description"
        content="Interactive 3D visualization of a binary black hole inspiral and merger using Peters (1964) gravitational wave radiation equations.">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Binary Black Hole Merger | Mitchell Hooymans">
    <meta property="og:description"
        content="Interactive 3D visualization of a binary black hole inspiral and merger using Peters (1964) gravitational wave radiation equations.">
    <meta property="og:image" content="../images/general/milkyway.jpg">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Styles -->
    <link rel="stylesheet" href="../styles.css">
    <link rel="shortcut icon" href="../images/favicon/favicon.ico" type="image/x-icon">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, { delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}] });"></script>

    <style>
        body {
            overflow-x: hidden;
        }

        .content-section {
            max-width: 1000px;
            margin: 0 auto;
        }

        .simulation-container {
            background: #000;
            border-radius: var(--radius-xl);
            overflow: hidden;
            box-shadow: var(--shadow-xl);
            border: 1px solid rgba(255, 255, 255, 0.3);
            position: relative;
            width: 100%;
            display: flex;
            flex-direction: column;
        }

        #simulationCanvas {
            display: block;
            width: 100%;
            height: 60%;
            aspect-ratio: 16/9;
        }

        .gw-graph-container {
            width: 100%;
            height: 40%;
            background: #0a0a0a;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            padding: 10px;
        }

        #gwGraph {
            width: 100%;
            height: 100%;
            display: block;
        }

        .gw-graph-title {
            position: absolute;
            top: 10px;
            left: 15px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.85rem;
            font-family: 'Inter', sans-serif;
            pointer-events: none;
        }

        /* Simulation + controls wrapper */
        .simulation-wrapper {
            display: grid;
            grid-template-columns: 1fr;
            gap: var(--space-6);
        }

        @media (min-width: 900px) {
            .simulation-wrapper {
                grid-template-columns: 1fr 300px;
            }
        }

        .controls-panel {
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-xl);
            padding: var(--space-5);
            max-height: 800px;
            overflow-y: auto;
        }

        .controls-title {
            font-family: 'Inter', sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
        }

        .control-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-section h4 {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 12px;
            font-weight: 600;
        }

        .control-group {
            margin-bottom: 16px;
        }

        .control-group label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            margin-bottom: 8px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
        }

        .control-group input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--color-accent);
        }

        .value-display {
            color: var(--color-accent);
            font-weight: 600;
            font-size: 0.9rem;
        }

        .btn-reset {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-secondary) 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
            font-weight: 600;
            font-size: 0.95rem;
            margin-top: 10px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn-reset:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(var(--color-accent-rgb), 0.4);
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 20;
            transition: opacity 0.5s;
        }

        .info-card {
            background: linear-gradient(135deg, var(--color-primary-dark) 0%, var(--color-primary) 100%);
            color: var(--color-white);
            border-radius: var(--radius-xl);
            padding: var(--space-6);
            margin-bottom: var(--space-6);
        }

        .info-card h3 {
            color: var(--color-white);
            margin-bottom: var(--space-3);
            font-size: 1.1rem;
        }

        .info-card p {
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: var(--space-3);
            line-height: 1.6;
            font-size: 0.95rem;
        }

        /* Data Readouts */
        .data-readout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .data-item {
            display: flex;
            flex-direction: column;
        }

        .data-label {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
        }

        .data-value {
            font-family: monospace;
            font-size: 1rem;
            color: white;
        }

        /* Full Browser Mode */
        body.full-browser {
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        body.full-browser .nav,
        body.full-browser .page-header,
        body.full-browser .footer,
        body.full-browser .back-link,
        body.full-browser .info-card {
            display: none !important;
        }

        body.full-browser .section {
            padding: 0 !important;
            margin: 0 !important;
        }

        body.full-browser .container {
            max-width: none !important;
            width: 100vw !important;
            height: 100vh !important;
            padding: 0 !important;
        }

        body.full-browser .content-section {
            max-width: none !important;
            margin: 0 !important;
            height: 100% !important;
        }

        body.full-browser .simulation-wrapper {
            grid-template-columns: 1fr !important;
            height: 100% !important;
            gap: 0 !important;
        }

        body.full-browser .simulation-container {
            border-radius: 0 !important;
            height: 100% !important;
        }

        body.full-browser .controls-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 320px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            z-index: 1000;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
            font-weight: 600;
            font-size: 0.95rem;
            margin-top: 10px;
            transition: all 0.2s;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
        }
    </style>

    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <!-- Global Nebula Background -->
    <div class="global-nebula">
        <div class="nebula-glow"></div>
        <div class="nebula-glow"></div>
    </div>

    <!-- Navbar -->
    <div id="navbar-placeholder"></div>
    <script src="../js/navbar.js"></script>

    <!-- Page Header -->
    <header class="page-header">
        <div class="container">
            <a href="javascript:history.back()" class="back-link">
                <i class="fas fa-arrow-left"></i> Back
            </a>
            <h1>Binary Black Hole Merger</h1>
            <p>
                An interactive visualization of a binary black hole system inspiraling and merging due to the emission
                of gravitational waves (Peters 1964).
            </p>
        </div>
    </header>

    <!-- Main Content -->
    <section class="section">
        <div class="container">
            <div class="content-section">
                <!-- Info Card -->
                <div class="info-card">
                    <h3><i class="fas fa-bullseye"></i> Gravitational Wave Inspiral</h3>
                    <p>
                        Two massive black holes orbiting a common center of mass will emit <strong>Gravitational
                            Waves</strong> (ripples in spacetime).
                        As energy is radiated away, their orbit shrinks and circularises over time until they violently
                        merge.
                    </p>
                    <p style="font-size: 0.85rem; opacity: 0.9;">
                        <strong>Peters' Equations:</strong> This simulation integrates the coupled differential
                        equations for semi-major axis ($a$) and eccentricity ($e$) derived by P.C. Peters in 1964.
                    </p>
                </div>

                <!-- Simulation + Controls Wrapper -->
                <div class="simulation-wrapper">
                    <!-- Simulation Canvas -->
                    <div class="simulation-container">
                        <div id="loading" class="loading-overlay">Initializing Cosmos...</div>
                        <canvas id="simulationCanvas"></canvas>
                        <div class="gw-graph-container">
                            <div class="gw-graph-title">Gravitational Wave Frequency (Chirp)</div>
                            <canvas id="gwGraph"></canvas>
                        </div>
                    </div>

                    <!-- Controls Panel -->
                    <div class="controls-panel">
                        <div class="controls-title">
                            <i class="fas fa-sliders-h"></i> System Parameters
                        </div>

                        <div class="control-section">
                            <h4>Black Hole Masses</h4>
                            <div class="control-group">
                                <label>Primary ($M_1$): <span id="m1Val" class="value-display">30.0</span>
                                    $M_\odot$</label>
                                <input type="range" id="mass1Input" min="5" max="100" step="1" value="30">
                            </div>

                            <div class="control-group">
                                <label>Secondary ($M_2$): <span id="m2Val" class="value-display">30.0</span>
                                    $M_\odot$</label>
                                <input type="range" id="mass2Input" min="5" max="100" step="1" value="30">
                            </div>
                        </div>

                        <div class="control-section">
                            <h4>Orbital Parameters</h4>
                            <div class="control-group">
                                <label>Initial Separation ($a_0$): <span id="a0Val" class="value-display">1.0</span>
                                    AU</label>
                                <input type="range" id="a0Input" min="0.1" max="5.0" step="0.1" value="1.0">
                            </div>

                            <div class="control-group">
                                <label>Initial Eccentricity ($e_0$): <span id="e0Val"
                                        class="value-display">0.50</span></label>
                                <input type="range" id="e0Input" min="0.0" max="0.95" step="0.05" value="0.5">
                            </div>
                        </div>

                        <div class="control-section">
                            <h4>Simulation Config</h4>
                            <div class="control-group">
                                <label>Time Speed: <span id="speedVal" class="value-display">1.0</span>x</label>
                                <input type="range" id="speedInput" min="0.1" max="5.0" step="0.1" value="1.0">
                            </div>

                            <div class="data-readout">
                                <div class="data-item">
                                    <span class="data-label">Current Separation</span>
                                    <span class="data-value" id="currentA">1.000 AU</span>
                                </div>
                                <div class="data-item">
                                    <span class="data-label">Current Eccentricity</span>
                                    <span class="data-value" id="currentE">0.500</span>
                                </div>
                                <div class="data-item">
                                    <span class="data-label">GW Frequency</span>
                                    <span class="data-value" id="currentF">0.00 Hz</span>
                                </div>
                                <div class="data-item">
                                    <span class="data-label">Phase</span>
                                    <span class="data-value" id="currentPhase">Inspiral</span>
                                </div>
                                <div class="data-item">
                                    <span class="data-label">Chirp Mass</span>
                                    <span class="data-value" id="chirpMassVal">-- M&#x2299;</span>
                                </div>
                                <div class="data-item">
                                    <span class="data-label">Peak Harmonic</span>
                                    <span class="data-value" id="peakHarmonicVal">n=2</span>
                                </div>
                                <div class="data-item">
                                    <span class="data-label">GW Power</span>
                                    <span class="data-value" id="gwPowerVal">--</span>
                                </div>
                                <div class="data-item" id="finalSpinItem" style="display: none;">
                                    <span class="data-label">Final Spin</span>
                                    <span class="data-value" id="finalSpinVal">--</span>
                                </div>
                                <div class="data-item" id="finalMassItem" style="display: none;">
                                    <span class="data-label">Final Mass</span>
                                    <span class="data-value" id="finalMassVal">--</span>
                                </div>
                            </div>
                        </div>

                        <button id="resetBtn" class="btn-reset">
                            <i class="fas fa-sync-alt"></i> Reset Simulation
                        </button>

                        <button id="pauseBtn" class="btn-secondary">
                            <i class="fas fa-pause"></i> Pause
                        </button>

                        <button id="playChirpBtn" class="btn-secondary">
                            <i class="fas fa-volume-up"></i> Play Chirp
                        </button>

                        <button id="fullBrowserBtn" class="btn-secondary">
                            <i class="fas fa-expand"></i> Full Browser
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <div id="footer-placeholder"></div>
    <script src="../js/footer.js"></script>
    <script>new Footer().init('../');</script>



    <!-- Simulation Script will go here -->
    <script type="module" id="sim-script">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Constants & State ---
        // For visual purposes, we scale physical constants heavily so the simulation runs
        // interactively in real-time.
        const CONSTANTS = {
            G: 1,      // Scaled Gravitational Constant
            c: 50,     // Scaled Speed of Light (determines inspiral rate. Smaller = faster)
        };

        const state = {
            m1: 30.0,
            m2: 30.0,
            a0: 1.0,
            e0: 0.5,
            timeScale: 1.0,
            // Dynamic variables
            a: 1.0,
            e: 0.5,
            meanAnomaly: 0,
            isMerged: false,
            isPaused: false,
            // Ringdown state
            isRingdown: false,
            ringdownTime: 0,
            ringdownFreq: 0,      // quasi-normal mode frequency
            ringdownTau: 0,       // damping timescale
            mergerStrainPeak: 0,  // peak strain at merger for ringdown envelope
            finalMass: 0,         // M_final after energy radiated
            finalSpin: 0,         // dimensionless spin of final BH
            // Graph Data
            gwHistory: [],
            maxHistory: 300,
        };

        // --- DOM Elements ---
        const container = document.querySelector('.simulation-container');
        const canvas = document.getElementById('simulationCanvas');
        const loading = document.getElementById('loading');

        // Graph
        const gwCanvas = document.getElementById('gwGraph');
        const gwCtx = gwCanvas.getContext('2d');
        gwCanvas.width = gwCanvas.parentElement.clientWidth;
        gwCanvas.height = gwCanvas.parentElement.clientHeight;

        // UI
        const ui = {
            m1: document.getElementById('mass1Input'),
            m2: document.getElementById('mass2Input'),
            a0: document.getElementById('a0Input'),
            e0: document.getElementById('e0Input'),
            speed: document.getElementById('speedInput'),
            resetBtn: document.getElementById('resetBtn'),
            m1Val: document.getElementById('m1Val'),
            m2Val: document.getElementById('m2Val'),
            a0Val: document.getElementById('a0Val'),
            e0Val: document.getElementById('e0Val'),
            speedVal: document.getElementById('speedVal'),
            currentA: document.getElementById('currentA'),
            currentE: document.getElementById('currentE'),
            currentF: document.getElementById('currentF')
        };

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x040a1a);
        scene.fog = new THREE.FogExp2(0x040a1a, 0.012);

        const camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
        camera.position.set(0, 3, 5);

        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- Scene Objects ---
        // Black holes Custom Shader
        const bhGeometry = new THREE.SphereGeometry(1, 32, 32);

        const vertexShader = `
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                vViewPosition = -mvPosition.xyz;
                gl_Position = projectionMatrix * mvPosition;
            }
        `;
        const fragmentShader = `
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            void main() {
                vec3 normal = normalize(vNormal);
                vec3 viewDir = normalize(vViewPosition);
                float fresnel = dot(viewDir, normal);
                fresnel = clamp(1.0 - fresnel, 0.0, 1.0);
                fresnel = pow(fresnel, 5.0); // sharp edge for lensing
                vec3 edgeColor = vec3(0.5, 0.7, 1.0); 
                vec3 color = edgeColor * fresnel * 2.5; 
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        const bhMaterial = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            transparent: false
        });

        const bh1 = new THREE.Mesh(bhGeometry, bhMaterial);
        const bh2 = new THREE.Mesh(bhGeometry, bhMaterial);
        scene.add(bh1);
        scene.add(bh2);

        let mergedBH; // Created upon merger

        // Fading Orbital Trails
        const trailMaterial1 = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, blending: THREE.AdditiveBlending });
        const trailGeometry1 = new THREE.BufferGeometry();
        const trail1 = new THREE.Line(trailGeometry1, trailMaterial1);
        scene.add(trail1);

        const trailMaterial2 = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, blending: THREE.AdditiveBlending });
        const trailGeometry2 = new THREE.BufferGeometry();
        const trail2 = new THREE.Line(trailGeometry2, trailMaterial2);
        scene.add(trail2);

        let trailPositions1 = [];
        let trailPositions2 = [];
        const maxTrailVertices = 200;

        // Background Stars
        const starsGeometry = new THREE.BufferGeometry();
        const starsCount = 2000;
        const posArray = new Float32Array(starsCount * 3);
        const colorArray = new Float32Array(starsCount * 3);
        const cColor = new THREE.Color();
        for (let i = 0; i < starsCount * 3; i += 3) {
            // Sphere surface distribution
            const r = 100 + Math.random() * 200;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            posArray[i] = r * Math.sin(phi) * Math.cos(theta);
            posArray[i + 1] = r * Math.sin(phi) * Math.sin(theta);
            posArray[i + 2] = r * Math.cos(phi);

            cColor.setHSL(Math.random(), 0.5, 0.5 + Math.random() * 0.5);
            colorArray[i] = cColor.r; colorArray[i + 1] = cColor.g; colorArray[i + 2] = cColor.b;
        }
        starsGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        starsGeometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
        const starsMaterial = new THREE.PointsMaterial({ size: 0.5, vertexColors: true, transparent: true });
        const starsMesh = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(starsMesh);



        // --- Physics & Peters 1964 ---

        // Solve Kepler's equation M = E - e sin(E) via Newton-Raphson
        function solveKepler(M, e) {
            let E = M;
            for (let i = 0; i < 15; i++) {
                const dE = (E - e * Math.sin(E) - M) / (1 - e * Math.cos(E));
                E -= dE;
                if (Math.abs(dE) < 1e-12) break;
            }
            return E;
        }

        // Peters (1964) da/dt and de/dt derivatives
        function petersDerivatives(a, e) {
            const G = CONSTANTS.G;
            const c = CONSTANTS.c;
            const m1 = state.m1;
            const m2 = state.m2;
            const M = m1 + m2;
            const e2 = e * e;
            const oneMinusE2 = 1 - e2;

            const commonFactor = (Math.pow(G, 3) * m1 * m2 * M) / Math.pow(c, 5);

            // da/dt (Peters 1964, Eq. 5.6)
            const da_dt = -(64.0 / 5.0) * commonFactor
                / (Math.pow(a, 3) * Math.pow(oneMinusE2, 3.5))
                * (1 + (73.0 / 24.0) * e2 + (37.0 / 96.0) * e2 * e2);

            // de/dt (Peters 1964, Eq. 5.7)
            let de_dt = 0;
            if (e > 1e-6) {
                de_dt = -(304.0 / 15.0) * e * commonFactor
                    / (Math.pow(a, 4) * Math.pow(oneMinusE2, 2.5))
                    * (1 + (121.0 / 304.0) * e2);
            }

            return [da_dt, de_dt];
        }

        // RK4 integration of orbital elements with adaptive sub-stepping
        function integrateOrbit(dt) {
            // Sub-step to maintain accuracy during late inspiral
            const N = Math.max(1, Math.ceil(dt / 0.002));
            const h = dt / N;

            for (let step = 0; step < N; step++) {
                const a0 = state.a;
                const e0 = state.e;

                const [k1a, k1e] = petersDerivatives(a0, e0);
                const [k2a, k2e] = petersDerivatives(
                    Math.max(0.005, a0 + 0.5 * h * k1a),
                    Math.max(0, Math.min(0.999, e0 + 0.5 * h * k1e))
                );
                const [k3a, k3e] = petersDerivatives(
                    Math.max(0.005, a0 + 0.5 * h * k2a),
                    Math.max(0, Math.min(0.999, e0 + 0.5 * h * k2e))
                );
                const [k4a, k4e] = petersDerivatives(
                    Math.max(0.005, a0 + h * k3a),
                    Math.max(0, Math.min(0.999, e0 + h * k3e))
                );

                state.a += (h / 6) * (k1a + 2 * k2a + 2 * k3a + k4a);
                state.e += (h / 6) * (k1e + 2 * k2e + 2 * k3e + k4e);

                // Clamp to physical ranges
                if (state.e < 0) state.e = 0;
                if (state.e > 0.99) state.e = 0.99;
                if (state.a < 0.01) { state.a = 0.01; break; }
            }
        }

        // Compute peak GW harmonic number for eccentric orbits
        // Peters & Mathews (1963): n_peak ~ (1+e)^1.1954 / (1-e^2)^1.5
        function peakHarmonic(e) {
            if (e < 0.001) return 2;
            return 2 * Math.pow(1 + e, 1.1954) / Math.pow(1 - e * e, 1.5);
        }

        // Chirp mass: M_c = (m1*m2)^(3/5) / (m1+m2)^(1/5)
        function chirpMass(m1, m2) {
            return Math.pow(m1 * m2, 3 / 5) / Math.pow(m1 + m2, 1 / 5);
        }

        // Peters (1964) GW luminosity enhancement factor f(e)
        function gwEnhancement(e) {
            const e2 = e * e;
            return (1 + (73.0 / 24.0) * e2 + (37.0 / 96.0) * e2 * e2)
                / Math.pow(1 - e2, 3.5);
        }

        // Hofmann-Barausse-Rezzolla (2016) final spin for non-spinning BBH
        function computeFinalSpin(nu) {
            // a_f = sqrt(12)*nu - 3.871*nu^2 + 4.028*nu^3
            return Math.sqrt(12) * nu - 3.871 * nu * nu + 4.028 * nu * nu * nu;
        }

        // Barausse-Rezzolla energy radiated fraction for non-spinning BBH
        function computeRadiatedFraction(nu) {
            // E_rad/M ~ 0.0559745 * 4*nu^2 + 0.00169 * 4*nu
            return Math.min(0.0559745 * 4 * nu * nu + 0.00169 * 4 * nu, 0.11);
        }

        // Echeverria/Leaver QNM frequency for l=2 m=2 mode
        function qnmFrequency(Mf, af) {
            const G = CONSTANTS.G;
            const c = CONSTANTS.c;
            // f_QNM = c^3/(2*pi*G*Mf) * [1 - 0.63*(1-af)^0.3]
            return (c * c * c) / (2 * Math.PI * G * Mf) * (1 - 0.63 * Math.pow(1 - af, 0.3));
        }

        // Echeverria QNM quality factor Q for l=2 m=2 mode
        function qnmQualityFactor(af) {
            // Q = 0.7 + 1.4187 * (1-af)^(-0.4990)
            return 0.7 + 1.4187 * Math.pow(1 - Math.min(af, 0.998), -0.4990);
        }

        function updatePhysics(dt) {
            // --- RINGDOWN PHASE: damped QNM oscillation after merger ---
            if (state.isRingdown) {
                state.ringdownTime += dt;
                // Damped quasi-normal mode: h(t) = A * exp(-t/tau) * cos(2*pi*f_QNM*t)
                const amplitude = state.mergerStrainPeak * Math.exp(-state.ringdownTime / state.ringdownTau);
                const h = amplitude * Math.cos(2 * Math.PI * state.ringdownFreq * state.ringdownTime);

                // Visual: pulsate the merged BH mesh at QNM frequency
                if (mergedBH) {
                    const baseScale = calculateSchwarzschildRadius(state.finalMass);
                    const pulsate = 1.0 + 0.08 * Math.exp(-state.ringdownTime / state.ringdownTau)
                        * Math.sin(2 * Math.PI * state.ringdownFreq * state.ringdownTime * 2);
                    mergedBH.scale.set(baseScale * pulsate, baseScale * pulsate, baseScale * pulsate);
                }

                // Record ringdown waveform
                state.gwHistory.push({ time: Date.now(), f: state.ringdownFreq, h: h });
                if (state.gwHistory.length > state.maxHistory) {
                    state.gwHistory.shift();
                }

                // End ringdown when amplitude decays below 1% of peak
                if (Math.abs(amplitude) < state.mergerStrainPeak * 0.01) {
                    state.isRingdown = false;
                    if (mergedBH) {
                        const finalScale = calculateSchwarzschildRadius(state.finalMass);
                        mergedBH.scale.set(finalScale, finalScale, finalScale);
                    }
                }
                return;
            }

            if (state.isMerged) return; // fully settled post-ringdown

            // --- INSPIRAL PHASE: Peters (1964) orbital decay + Keplerian motion ---
            const G = CONSTANTS.G;
            const c = CONSTANTS.c;
            const m1 = state.m1;
            const m2 = state.m2;
            const M = m1 + m2;
            const mu = (m1 * m2) / M; // reduced mass

            // Integrate orbital elements with RK4
            integrateOrbit(dt);

            // Keplerian mean motion
            const n = Math.sqrt((G * M) / Math.pow(state.a, 3));
            state.meanAnomaly += n * dt;
            if (state.meanAnomaly > Math.PI * 2) {
                state.meanAnomaly -= Math.PI * 2;
            }

            // Solve Kepler's equation for eccentric anomaly
            const E = solveKepler(state.meanAnomaly, state.e);
            const trueAnomaly = 2 * Math.atan2(
                Math.sqrt(1 + state.e) * Math.sin(E / 2),
                Math.sqrt(1 - state.e) * Math.cos(E / 2)
            );

            // Instantaneous separation
            const r = state.a * (1 - state.e * Math.cos(E));

            // Positions in orbital plane (barycenter at origin)
            const x = r * Math.cos(trueAnomaly);
            const z = r * Math.sin(trueAnomaly);
            const r1_ratio = m2 / M;
            const r2_ratio = -m1 / M;
            const p1 = new THREE.Vector3(x * r1_ratio, 0, z * r1_ratio);
            const p2 = new THREE.Vector3(x * r2_ratio, 0, z * r2_ratio);

            // --- MERGER CHECK: when visual spheres touch ---
            const r1_vis = calculateSchwarzschildRadius(m1);
            const r2_vis = calculateSchwarzschildRadius(m2);
            if (r <= r1_vis + r2_vis) {
                state.isMerged = true;
                scene.remove(bh1);
                scene.remove(bh2);

                // Symmetric mass ratio
                const nu = (m1 * m2) / (M * M);

                // Barausse-Rezzolla energy radiated fraction (calibrated to NR)
                const radiatedFraction = computeRadiatedFraction(nu);
                state.finalMass = M * (1 - radiatedFraction);

                // Hofmann-Barausse-Rezzolla final spin
                state.finalSpin = Math.max(0, Math.min(0.998, computeFinalSpin(nu)));

                // Create merged BH mesh
                if (!mergedBH) {
                    mergedBH = new THREE.Mesh(bhGeometry, bhMaterial);
                    scene.add(mergedBH);
                }
                mergedBH.visible = true;
                mergedBH.position.set(0, 0, 0);
                const r_final = calculateSchwarzschildRadius(state.finalMass);
                mergedBH.scale.set(r_final, r_final, r_final);

                // QNM ringdown parameters
                // In our scaled-constant system, we derive ringdown params
                // relative to the simulation's timescales to ensure visibility.
                const Q = qnmQualityFactor(state.finalSpin);

                // Get the last inspiral GW frequency as our anchor
                const lastF = state.gwHistory.length > 0
                    ? state.gwHistory[state.gwHistory.length - 1].f
                    : 1.0;

                // QNM frequency: physically ~1.5x last GW freq, but capped
                // so we get enough samples per cycle for the graph to resolve.
                // At ~30fps with dtScaled~0.03, we need f < ~4 Hz sim-units
                // to get ~8 samples per cycle for a smooth waveform.
                const spinFactor = 1 - 0.63 * Math.pow(1 - state.finalSpin, 0.3);
                const rawFreq = lastF * (1.0 + spinFactor);
                state.ringdownFreq = Math.min(rawFreq, 4.0);

                // Damping timescale: Q cycles / (pi * f), with a floor
                // to guarantee the ringdown is visible for ~2 real-time seconds
                state.ringdownTau = Math.max(Q / (Math.PI * state.ringdownFreq), 0.6);

                // Peak strain at merger (from last inspiral sample, boosted)
                const lastStrain = state.gwHistory.length > 0
                    ? Math.abs(state.gwHistory[state.gwHistory.length - 1].h)
                    : 1.0;
                state.mergerStrainPeak = lastStrain * 2.5;
                state.ringdownTime = 0;
                state.isRingdown = true;
                return;
            }

            bh1.position.copy(p1);
            bh2.position.copy(p2);
            updateTrails(p1, p2);

            // --- GW Strain: Peters & Mathews (1963) quadrupole formula ---
            // h+ for face-on (iota=0) dominant l=2, m=2 mode with eccentric harmonics
            const semiLatusRectum = state.a * (1 - state.e * state.e);
            const prefactor = (mu * M) / Math.max(semiLatusRectum, 0.001);

            // Full quadrupole: includes harmonics at f_orb, 2*f_orb, 3*f_orb
            const hPlus = -prefactor * (
                2 * Math.cos(2 * trueAnomaly)
                + (5.0 / 2.0) * state.e * Math.cos(trueAnomaly)
                + (1.0 / 2.0) * state.e * Math.cos(3 * trueAnomaly)
                + state.e * state.e
            );

            // GW Frequency: peak harmonic for eccentric orbits
            const f_orbital = n / (2 * Math.PI);
            const n_peak = peakHarmonic(state.e);
            const f_gw = n_peak * f_orbital; // dominant GW frequency

            state.gwHistory.push({ time: Date.now(), f: f_gw, h: hPlus, n_peak: n_peak });
            if (state.gwHistory.length > state.maxHistory) {
                state.gwHistory.shift();
            }
        }

        function calculateSchwarzschildRadius(mass) {
            // R_s = 2GM/c^2, scaled for visual display
            // Scale factor 6 keeps spheres smaller than orbital separation
            return Math.max(0.04, (2 * CONSTANTS.G * mass) / (CONSTANTS.c * CONSTANTS.c) * 6);
        }

        function updateTrails(p1, p2) {
            trailPositions1.push(p1.x, p1.y, p1.z);
            if (trailPositions1.length > maxTrailVertices * 3) {
                trailPositions1.splice(0, 3);
            }
            trailGeometry1.setAttribute('position', new THREE.Float32BufferAttribute(trailPositions1, 3));

            trailPositions2.push(p2.x, p2.y, p2.z);
            if (trailPositions2.length > maxTrailVertices * 3) {
                trailPositions2.splice(0, 3);
            }
            trailGeometry2.setAttribute('position', new THREE.Float32BufferAttribute(trailPositions2, 3));

            // Fading colors
            const colors1 = [];
            const colors2 = [];
            const count1 = trailPositions1.length / 3;
            for (let i = 0; i < count1; i++) {
                const intensity = (i / count1); // fade factor
                colors1.push(1.0 * intensity, 0.6 * intensity, 0.0);
                colors2.push(0.0, 0.6 * intensity, 1.0 * intensity);
            }
            trailGeometry1.setAttribute('color', new THREE.Float32BufferAttribute(colors1, 3));
            trailGeometry2.setAttribute('color', new THREE.Float32BufferAttribute(colors2, 3));
        }

        function drawGWGraph() {
            gwCtx.clearRect(0, 0, gwCanvas.width, gwCanvas.height);

            if (state.gwHistory.length < 2) return;

            // Draw axes
            gwCtx.strokeStyle = 'rgba(255,255,255,0.2)';
            gwCtx.beginPath();
            gwCtx.moveTo(0, gwCanvas.height / 2);
            gwCtx.lineTo(gwCanvas.width, gwCanvas.height / 2);
            gwCtx.stroke();

            // The Strain Graph (Chirp)
            gwCtx.beginPath();
            gwCtx.strokeStyle = 'var(--color-accent)';
            gwCtx.lineWidth = 2;

            // Dynamic scaling based on recent history
            let maxH = 0.01;
            for (let pt of state.gwHistory) {
                if (Math.abs(pt.h) > maxH) maxH = Math.abs(pt.h);
            }

            for (let i = 0; i < state.gwHistory.length; i++) {
                const pt = state.gwHistory[i];
                const x = (i / state.maxHistory) * gwCanvas.width;
                // Map strain to Y, centered
                const y = gwCanvas.height / 2 - (pt.h / maxH) * (gwCanvas.height / 2.5);

                if (i === 0) gwCtx.moveTo(x, y);
                else gwCtx.lineTo(x, y);
            }
            gwCtx.stroke();

            // Frequency overlay text
            const lastPt = state.gwHistory[state.gwHistory.length - 1];
            ui.currentF.innerText = `${lastPt.f.toFixed(3)} Hz`;

            // Update peak harmonic display
            const peakH = document.getElementById('peakHarmonicVal');
            if (lastPt.n_peak !== undefined) {
                peakH.innerText = `n=${lastPt.n_peak.toFixed(1)}`;
            }
        }

        // --- Initialization & Loop ---

        function initSimulation() {
            state.m1 = parseFloat(ui.m1.value);
            state.m2 = parseFloat(ui.m2.value);
            state.a0 = parseFloat(ui.a0.value);
            state.e0 = parseFloat(ui.e0.value);
            state.timeScale = parseFloat(ui.speed.value);

            state.a = state.a0;
            state.e = state.e0;
            state.meanAnomaly = 0;
            state.isMerged = false;
            state.isPaused = false;
            state.isRingdown = false;
            state.ringdownTime = 0;
            state.finalMass = 0;
            state.finalSpin = 0;
            state.gwHistory = [];
            trailPositions1 = [];
            trailPositions2 = [];
            trailGeometry1.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
            trailGeometry2.setAttribute('position', new THREE.Float32BufferAttribute([], 3));

            // Restore visibility of individual BHs
            scene.add(bh1);
            scene.add(bh2);
            if (mergedBH) mergedBH.visible = false;

            // Initial BH sizes based on mass
            const r1 = calculateSchwarzschildRadius(state.m1);
            const r2 = calculateSchwarzschildRadius(state.m2);
            bh1.scale.set(r1, r1, r1);
            bh2.scale.set(r2, r2, r2);

            updateUI();
        }

        function updateUI() {
            ui.m1Val.innerText = ui.m1.value;
            ui.m2Val.innerText = ui.m2.value;
            ui.a0Val.innerText = ui.a0.value;
            ui.e0Val.innerText = ui.e0.value;
            ui.speedVal.innerText = ui.speed.value;

            // Chirp mass (always valid)
            const Mc = chirpMass(state.m1, state.m2);
            document.getElementById('chirpMassVal').innerText = `${Mc.toFixed(1)} M\u2299`;

            // GW Power (during inspiral)
            if (!state.isMerged) {
                const G = CONSTANTS.G;
                const c = CONSTANTS.c;
                const m1 = state.m1;
                const m2 = state.m2;
                const M = m1 + m2;
                const fe = gwEnhancement(state.e);
                const Pgw = (32.0 / 5.0) * Math.pow(G, 4) * m1 * m1 * m2 * m2 * M
                    / (Math.pow(c, 5) * Math.pow(state.a, 5)) * fe;
                // Format power in scientific notation
                if (Pgw > 0 && isFinite(Pgw)) {
                    const exp = Math.floor(Math.log10(Pgw));
                    const mantissa = Pgw / Math.pow(10, exp);
                    document.getElementById('gwPowerVal').innerText = `${mantissa.toFixed(1)}e${exp}`;
                } else {
                    document.getElementById('gwPowerVal').innerText = '--';
                }
            }

            if (!state.isMerged) {
                ui.currentA.innerText = `${state.a.toFixed(3)} AU`;
                ui.currentE.innerText = state.e.toFixed(3);
                document.getElementById('currentPhase').innerText = 'Inspiral';
                document.getElementById('finalMassItem').style.display = 'none';
                document.getElementById('finalSpinItem').style.display = 'none';
            } else if (state.isRingdown) {
                ui.currentA.innerText = 'MERGED';
                ui.currentE.innerText = 'MERGED';
                document.getElementById('currentPhase').innerText = 'Ringdown';
                document.getElementById('finalMassItem').style.display = '';
                document.getElementById('finalMassVal').innerText = `${state.finalMass.toFixed(1)} M\u2299`;
                document.getElementById('finalSpinItem').style.display = '';
                document.getElementById('finalSpinVal').innerText = `a = ${state.finalSpin.toFixed(3)}`;
                document.getElementById('gwPowerVal').innerText = 'Ringdown';
            } else {
                ui.currentA.innerText = 'MERGED';
                ui.currentE.innerText = 'MERGED';
                document.getElementById('currentPhase').innerText = 'Complete';
                document.getElementById('finalMassItem').style.display = '';
                document.getElementById('finalMassVal').innerText = `${state.finalMass.toFixed(1)} M\u2299`;
                document.getElementById('finalSpinItem').style.display = '';
                document.getElementById('finalSpinVal').innerText = `a = ${state.finalSpin.toFixed(3)}`;
                document.getElementById('gwPowerVal').innerText = '0';
            }
        }

        // Event Listeners
        const inputs = [ui.m1, ui.m2, ui.a0, ui.e0];
        inputs.forEach(input => {
            input.addEventListener('input', () => {
                updateUI();
                // We only auto-restart if slider ends? Actually, input fires continuously. 
                // Let's NOT auto-restart on input for performance, wait for change, 
                // but we DO update the UI values.
            });
            input.addEventListener('change', initSimulation);
        });

        ui.speed.addEventListener('input', () => {
            state.timeScale = parseFloat(ui.speed.value);
            ui.speedVal.innerText = ui.speed.value;
        });

        ui.resetBtn.addEventListener('click', initSimulation);

        // Pause toggle
        const pauseBtn = document.getElementById('pauseBtn');
        pauseBtn.addEventListener('click', () => {
            state.isPaused = !state.isPaused;
            pauseBtn.innerHTML = state.isPaused
                ? '<i class="fas fa-play"></i> Resume'
                : '<i class="fas fa-pause"></i> Pause';
        });

        // --- Chirp Audio Playback (Web Audio API) ---
        let audioCtx = null;
        const playChirpBtn = document.getElementById('playChirpBtn');
        playChirpBtn.addEventListener('click', () => {
            if (state.gwHistory.length < 10) return;
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            // Build frequency curve from recorded GW history
            const history = state.gwHistory;
            const duration = 3.5; // playback duration in seconds
            const sampleRate = audioCtx.sampleRate;
            const totalSamples = Math.floor(sampleRate * duration);

            const buffer = audioCtx.createBuffer(1, totalSamples, sampleRate);
            const data = buffer.getChannelData(0);

            // Find frequency extremes and detect merger point
            let fMin = Infinity, fMax = -Infinity;
            let mergerIdx = history.length; // default: no merger in history
            for (let i = 0; i < history.length; i++) {
                if (history[i].f < fMin) fMin = history[i].f;
                if (history[i].f > fMax) fMax = history[i].f;
                // Detect transition to ringdown (frequency plateau after peak)
                if (i > 0 && history[i].n_peak === undefined && history[i - 1].n_peak !== undefined) {
                    mergerIdx = i;
                }
            }
            const fRange = Math.max(fMax - fMin, 0.01);

            // Map the recorded strain into a chirp with ringdown
            let phase = 0;
            for (let i = 0; i < totalSamples; i++) {
                const t = i / totalSamples; // normalized 0..1
                const histIdx = Math.floor(t * (history.length - 1));
                const pt = history[histIdx];

                // Scale GW frequency to audible range (80-1000 Hz)
                const fAudio = 80 + ((pt.f - fMin) / fRange) * 920;
                phase += (2 * Math.PI * fAudio) / sampleRate;

                // Amplitude envelope:
                // - Inspiral: gradual ramp-up
                // - Ringdown: exponential decay after merger
                let envelope;
                if (histIdx < mergerIdx) {
                    // Inspiral: amplitude grows ~ t^(1/4) for chirp-like feel
                    const inspiralFrac = histIdx / Math.max(mergerIdx, 1);
                    envelope = 0.2 + 0.8 * Math.pow(inspiralFrac, 0.25);
                } else {
                    // Ringdown: exponential decay
                    const ringFrac = (histIdx - mergerIdx) / Math.max(history.length - mergerIdx, 1);
                    envelope = Math.exp(-3.0 * ringFrac);
                }

                data[i] = Math.sin(phase) * envelope * 0.5;
            }

            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(audioCtx.destination);
            source.start();
        });

        // Full browser toggle
        document.getElementById('fullBrowserBtn').addEventListener('click', () => {
            document.body.classList.toggle('full-browser');
            setTimeout(onWindowResize, 100);
        });

        function onWindowResize() {
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);

            gwCanvas.width = gwCanvas.parentElement.clientWidth;
            gwCanvas.height = gwCanvas.parentElement.clientHeight;
        }
        window.addEventListener('resize', onWindowResize);

        // Hide loading
        loading.style.opacity = 0;
        setTimeout(() => loading.style.display = 'none', 500);

        // Main Loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            let dt = clock.getDelta();
            if (dt > 0.1) dt = 0.1;

            // Only run physics when not paused
            if (!state.isPaused) {
                const dtScaled = Math.min(dt * state.timeScale * 2.0, 0.1);
                updatePhysics(dtScaled);
            }

            controls.update();
            renderer.render(scene, camera);
            drawGWGraph();
            updateUI();
        }

        initSimulation();
        animate();
    </script>
</body>

</html>
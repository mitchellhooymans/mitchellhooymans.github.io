<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Black Hole Merger | Mitchell Hooymans</title>
    <meta name="description"
        content="Interactive 3D visualization of a binary black hole inspiral and merger using Peters (1964) gravitational wave radiation equations.">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Binary Black Hole Merger | Mitchell Hooymans">
    <meta property="og:description"
        content="Interactive 3D visualization of a binary black hole inspiral and merger using Peters (1964) gravitational wave radiation equations.">
    <meta property="og:image" content="../images/general/milkyway.jpg">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Styles -->
    <link rel="stylesheet" href="../styles.css">
    <link rel="shortcut icon" href="../images/favicon/favicon.ico" type="image/x-icon">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, { delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}] });"></script>

    <style>
        body {
            overflow-x: hidden;
        }

        .content-section {
            max-width: 1000px;
            margin: 0 auto;
        }

        .simulation-container {
            background: #000;
            border-radius: var(--radius-xl);
            overflow: hidden;
            box-shadow: var(--shadow-xl);
            border: 1px solid rgba(255, 255, 255, 0.3);
            position: relative;
            width: 100%;
            display: flex;
            flex-direction: column;
        }

        #simulationCanvas {
            display: block;
            width: 100%;
            height: 60%;
            aspect-ratio: 16/9;
        }

        .gw-graph-container {
            width: 100%;
            height: 40%;
            background: #0a0a0a;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            padding: 10px;
        }

        #gwGraph {
            width: 100%;
            height: 100%;
            display: block;
        }

        .gw-graph-title {
            position: absolute;
            top: 10px;
            left: 15px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.85rem;
            font-family: 'Inter', sans-serif;
            pointer-events: none;
        }

        /* Simulation + controls wrapper */
        .simulation-wrapper {
            display: grid;
            grid-template-columns: 1fr;
            gap: var(--space-6);
        }

        @media (min-width: 900px) {
            .simulation-wrapper {
                grid-template-columns: 1fr 300px;
            }
        }

        .controls-panel {
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-xl);
            padding: var(--space-5);
            max-height: 800px;
            overflow-y: auto;
        }

        .controls-title {
            font-family: 'Inter', sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
        }

        .control-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-section h4 {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 12px;
            font-weight: 600;
        }

        .control-group {
            margin-bottom: 16px;
        }

        .control-group label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            margin-bottom: 8px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
        }

        .control-group input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--color-accent);
        }

        .value-display {
            color: var(--color-accent);
            font-weight: 600;
            font-size: 0.9rem;
        }

        .btn-reset {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-secondary) 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
            font-weight: 600;
            font-size: 0.95rem;
            margin-top: 10px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn-reset:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(var(--color-accent-rgb), 0.4);
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 20;
            transition: opacity 0.5s;
        }

        .info-card {
            background: linear-gradient(135deg, var(--color-primary-dark) 0%, var(--color-primary) 100%);
            color: var(--color-white);
            border-radius: var(--radius-xl);
            padding: var(--space-6);
            margin-bottom: var(--space-6);
        }

        .info-card h3 {
            color: var(--color-white);
            margin-bottom: var(--space-3);
            font-size: 1.1rem;
        }

        .info-card p {
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: var(--space-3);
            line-height: 1.6;
            font-size: 0.95rem;
        }

        /* Data Readouts */
        .data-readout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .data-item {
            display: flex;
            flex-direction: column;
        }

        .data-label {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
        }

        .data-value {
            font-family: monospace;
            font-size: 1rem;
            color: white;
        }

        /* Full Browser Mode */
        body.full-browser {
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        body.full-browser .nav,
        body.full-browser .page-header,
        body.full-browser .footer,
        body.full-browser .back-link,
        body.full-browser .info-card {
            display: none !important;
        }

        body.full-browser .section {
            padding: 0 !important;
            margin: 0 !important;
        }

        body.full-browser .container {
            max-width: none !important;
            width: 100vw !important;
            height: 100vh !important;
            padding: 0 !important;
        }

        body.full-browser .content-section {
            max-width: none !important;
            margin: 0 !important;
            height: 100% !important;
        }

        body.full-browser .simulation-wrapper {
            grid-template-columns: 1fr !important;
            height: 100% !important;
            gap: 0 !important;
        }

        body.full-browser .simulation-container {
            border-radius: 0 !important;
            height: 100% !important;
        }

        body.full-browser .controls-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 320px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            z-index: 1000;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
            font-weight: 600;
            font-size: 0.95rem;
            margin-top: 10px;
            transition: all 0.2s;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
        }
    </style>

    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <!-- Global Nebula Background -->
    <div class="global-nebula">
        <div class="nebula-glow"></div>
        <div class="nebula-glow"></div>
    </div>

    <!-- Navbar -->
    <div id="navbar-placeholder"></div>
    <script src="../js/navbar.js"></script>

    <!-- Page Header -->
    <header class="page-header">
        <div class="container">
            <a href="javascript:history.back()" class="back-link">
                <i class="fas fa-arrow-left"></i> Back
            </a>
            <h1>Binary Black Hole Merger</h1>
            <p>
                An interactive visualization of a binary black hole system inspiraling and merging due to the emission
                of gravitational waves (Peters 1964).
            </p>
        </div>
    </header>

    <!-- Main Content -->
    <section class="section">
        <div class="container">
            <div class="content-section">
                <!-- Info Card -->
                <div class="info-card">
                    <h3><i class="fas fa-bullseye"></i> Gravitational Wave Inspiral</h3>
                    <p>
                        Two massive black holes orbiting a common center of mass will emit <strong>Gravitational
                            Waves</strong> (ripples in spacetime).
                        As energy is radiated away, their orbit shrinks and circularises over time until they violently
                        merge.
                    </p>
                    <p style="font-size: 0.85rem; opacity: 0.9;">
                        <strong>Peters' Equations:</strong> This simulation integrates the coupled differential
                        equations for semi-major axis ($a$) and eccentricity ($e$) derived by P.C. Peters in 1964.
                    </p>
                </div>

                <!-- Simulation + Controls Wrapper -->
                <div class="simulation-wrapper">
                    <!-- Simulation Canvas -->
                    <div class="simulation-container">
                        <div id="loading" class="loading-overlay">Initializing Cosmos...</div>
                        <canvas id="simulationCanvas"></canvas>
                        <div class="gw-graph-container">
                            <div class="gw-graph-title">Gravitational Wave Frequency (Chirp)</div>
                            <canvas id="gwGraph"></canvas>
                        </div>
                    </div>

                    <!-- Controls Panel -->
                    <div class="controls-panel">
                        <div class="controls-title">
                            <i class="fas fa-sliders-h"></i> System Parameters
                        </div>

                        <div class="control-section">
                            <h4>Black Hole Masses</h4>
                            <div class="control-group">
                                <label>Primary ($M_1$): <span id="m1Val" class="value-display">30.0</span>
                                    $M_\odot$</label>
                                <input type="range" id="mass1Input" min="5" max="100" step="1" value="30">
                            </div>

                            <div class="control-group">
                                <label>Secondary ($M_2$): <span id="m2Val" class="value-display">30.0</span>
                                    $M_\odot$</label>
                                <input type="range" id="mass2Input" min="5" max="100" step="1" value="30">
                            </div>
                        </div>

                        <div class="control-section">
                            <h4>Orbital Parameters</h4>
                            <div class="control-group">
                                <label>Initial Separation ($a_0$): <span id="a0Val" class="value-display">1.0</span>
                                    AU</label>
                                <input type="range" id="a0Input" min="0.1" max="5.0" step="0.1" value="1.0">
                            </div>

                            <div class="control-group">
                                <label>Initial Eccentricity ($e_0$): <span id="e0Val"
                                        class="value-display">0.50</span></label>
                                <input type="range" id="e0Input" min="0.0" max="0.95" step="0.05" value="0.5">
                            </div>
                        </div>

                        <div class="control-section">
                            <h4>Simulation Config</h4>
                            <div class="control-group">
                                <label>Time Speed: <span id="speedVal" class="value-display">1.0</span>x</label>
                                <input type="range" id="speedInput" min="0.1" max="5.0" step="0.1" value="1.0">
                            </div>

                            <div class="data-readout">
                                <div class="data-item">
                                    <span class="data-label">Current Separation</span>
                                    <span class="data-value" id="currentA">1.000 AU</span>
                                </div>
                                <div class="data-item">
                                    <span class="data-label">Current Eccentricity</span>
                                    <span class="data-value" id="currentE">0.500</span>
                                </div>
                                <div class="data-item" style="grid-column: 1 / -1;">
                                    <span class="data-label">GW Frequency</span>
                                    <span class="data-value" id="currentF">0.00 Hz</span>
                                </div>
                            </div>
                        </div>

                        <button id="resetBtn" class="btn-reset">
                            <i class="fas fa-sync-alt"></i> Reset Simulation
                        </button>

                        <button id="fullBrowserBtn" class="btn-secondary">
                            <i class="fas fa-expand"></i> Full Browser
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <div id="footer-placeholder"></div>
    <script src="../js/footer.js"></script>
    <script>new Footer().init('../');</script>



    <!-- Simulation Script will go here -->
    <script type="module" id="sim-script">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Constants & State ---
        // For visual purposes, we scale physical constants heavily so the simulation runs
        // interactively in real-time.
        const CONSTANTS = {
            G: 1,      // Scaled Gravitational Constant
            c: 50,     // Scaled Speed of Light (determines inspiral rate. Smaller = faster)
        };

        const state = {
            m1: 30.0,
            m2: 30.0,
            a0: 1.0,  // Initial semi-major axis (Visual Units ~ AU)
            e0: 0.5,  // Initial eccentricity
            timeScale: 1.0,
            // Dynamic variables
            a: 1.0,
            e: 0.5,
            meanAnomaly: 0,
            isMerged: false,
            // Graph Data
            gwHistory: [],
            maxHistory: 300,
        };

        // --- DOM Elements ---
        const container = document.querySelector('.simulation-container');
        const canvas = document.getElementById('simulationCanvas');
        const loading = document.getElementById('loading');

        // Graph
        const gwCanvas = document.getElementById('gwGraph');
        const gwCtx = gwCanvas.getContext('2d');
        gwCanvas.width = gwCanvas.parentElement.clientWidth;
        gwCanvas.height = gwCanvas.parentElement.clientHeight;

        // UI
        const ui = {
            m1: document.getElementById('mass1Input'),
            m2: document.getElementById('mass2Input'),
            a0: document.getElementById('a0Input'),
            e0: document.getElementById('e0Input'),
            speed: document.getElementById('speedInput'),
            resetBtn: document.getElementById('resetBtn'),
            m1Val: document.getElementById('m1Val'),
            m2Val: document.getElementById('m2Val'),
            a0Val: document.getElementById('a0Val'),
            e0Val: document.getElementById('e0Val'),
            speedVal: document.getElementById('speedVal'),
            currentA: document.getElementById('currentA'),
            currentE: document.getElementById('currentE'),
            currentF: document.getElementById('currentF')
        };

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020510);
        scene.fog = new THREE.FogExp2(0x020510, 0.015);

        const camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
        camera.position.set(0, 3, 5);

        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- Scene Objects ---
        // Black holes Custom Shader
        const bhGeometry = new THREE.SphereGeometry(1, 32, 32);

        const vertexShader = `
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                vViewPosition = -mvPosition.xyz;
                gl_Position = projectionMatrix * mvPosition;
            }
        `;
        const fragmentShader = `
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            void main() {
                vec3 normal = normalize(vNormal);
                vec3 viewDir = normalize(vViewPosition);
                float fresnel = dot(viewDir, normal);
                fresnel = clamp(1.0 - fresnel, 0.0, 1.0);
                fresnel = pow(fresnel, 5.0); // sharp edge for lensing
                vec3 edgeColor = vec3(0.5, 0.7, 1.0); 
                vec3 color = edgeColor * fresnel * 2.5; 
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        const bhMaterial = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            transparent: false
        });

        const bh1 = new THREE.Mesh(bhGeometry, bhMaterial);
        const bh2 = new THREE.Mesh(bhGeometry, bhMaterial);
        scene.add(bh1);
        scene.add(bh2);

        let mergedBH; // Created upon merger

        // Fading Orbital Trails
        const trailMaterial1 = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, blending: THREE.AdditiveBlending });
        const trailGeometry1 = new THREE.BufferGeometry();
        const trail1 = new THREE.Line(trailGeometry1, trailMaterial1);
        scene.add(trail1);

        const trailMaterial2 = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, blending: THREE.AdditiveBlending });
        const trailGeometry2 = new THREE.BufferGeometry();
        const trail2 = new THREE.Line(trailGeometry2, trailMaterial2);
        scene.add(trail2);

        let trailPositions1 = [];
        let trailPositions2 = [];
        const maxTrailVertices = 200;

        // Background Stars
        const starsGeometry = new THREE.BufferGeometry();
        const starsCount = 2000;
        const posArray = new Float32Array(starsCount * 3);
        const colorArray = new Float32Array(starsCount * 3);
        const cColor = new THREE.Color();
        for (let i = 0; i < starsCount * 3; i += 3) {
            // Sphere surface distribution
            const r = 100 + Math.random() * 200;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            posArray[i] = r * Math.sin(phi) * Math.cos(theta);
            posArray[i + 1] = r * Math.sin(phi) * Math.sin(theta);
            posArray[i + 2] = r * Math.cos(phi);

            cColor.setHSL(Math.random(), 0.5, 0.5 + Math.random() * 0.5);
            colorArray[i] = cColor.r; colorArray[i + 1] = cColor.g; colorArray[i + 2] = cColor.b;
        }
        starsGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        starsGeometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
        const starsMaterial = new THREE.PointsMaterial({ size: 0.5, vertexColors: true, transparent: true });
        const starsMesh = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(starsMesh);



        // --- Physics & Peters 1964 ---

        // Solve Kepler's equation M = E - e sin(E)
        function solveKepler(M, e) {
            let E = M;
            for (let i = 0; i < 10; i++) {
                E = E - (E - e * Math.sin(E) - M) / (1 - e * Math.cos(E));
            }
            return E;
        }

        function updatePhysics(dt) {
            if (state.isMerged) return;

            // Peters (1964) Equations for da/dt and de/dt
            // da/dt = -(64/5) * (G^3 m1 m2 (m1+m2)) / (c^5 a^3 (1-e^2)^(7/2)) * (1 + 73/24 e^2 + 37/96 e^4)
            // de/dt = -(304/15) * e * (G^3 m1 m2 (m1+m2)) / (c^5 a^4 (1-e^2)^(5/2)) * (1 + 121/304 e^2)

            const G = CONSTANTS.G;
            const c = CONSTANTS.c;
            const m1 = state.m1;
            const m2 = state.m2;
            const M = m1 + m2;

            // Check for merger based on physical Schwarzschild radii
            const r1_phys = calculatePhysicalRadius(m1);
            const r2_phys = calculatePhysicalRadius(m2);
            const r_isco = (r1_phys + r2_phys) * 3.0; // ~3x sum as ISCO proxy

            if (state.a * (1 - state.e) <= r_isco || state.a <= 0.005) {
                state.isMerged = true;

                // Remove individual meshes
                scene.remove(bh1);
                scene.remove(bh2);

                if (!mergedBH) {
                    mergedBH = new THREE.Mesh(bhGeometry, bhMaterial);
                    scene.add(mergedBH);
                }
                mergedBH.visible = true;
                mergedBH.position.set(0, 0, 0);

                const r_final = calculateSchwarzschildRadius(M);
                mergedBH.scale.set(r_final, r_final, r_final);
                return;
            }

            // Orbital evolution
            const factorA = -(64.0 / 5.0) * (Math.pow(G, 3) * m1 * m2 * M) / (Math.pow(c, 5) * Math.pow(state.a, 3) * Math.pow(1 - state.e * state.e, 3.5));
            const eTermsA = 1 + (73.0 / 24.0) * state.e * state.e + (37.0 / 96.0) * Math.pow(state.e, 4);
            const da_dt = factorA * eTermsA;

            let de_dt = 0;
            if (state.e > 0.0001) {
                const factorE = -(304.0 / 15.0) * state.e * (Math.pow(G, 3) * m1 * m2 * M) / (Math.pow(c, 5) * Math.pow(state.a, 4) * Math.pow(1 - state.e * state.e, 2.5));
                const eTermsE = 1 + (121.0 / 304.0) * state.e * state.e;
                de_dt = factorE * eTermsE;
            }

            state.a += da_dt * dt;
            state.e += de_dt * dt;

            if (state.e < 0) state.e = 0;
            if (state.e > 0.99) state.e = 0.99;
            if (state.a < 0.01) state.a = 0.01;

            // Keplerian Motion
            // Mean motion n = sqrt(G(m1+m2)/a^3)
            const n = Math.sqrt((G * M) / Math.pow(state.a, 3));
            state.meanAnomaly += n * dt;

            // Normalize anomaly
            if (state.meanAnomaly > Math.PI * 2) {
                state.meanAnomaly -= Math.PI * 2;
            }

            const E = solveKepler(state.meanAnomaly, state.e);

            // True anomaly nu
            const trueAnomaly = 2 * Math.atan(Math.sqrt((1 + state.e) / (1 - state.e)) * Math.tan(E / 2));

            // Distance r
            const r = state.a * (1 - state.e * Math.cos(E));

            // Positions in orbital plane
            const x = r * Math.cos(trueAnomaly);
            const z = r * Math.sin(trueAnomaly); // using x-z plane for orbit

            // Center of Mass (barycenter) is at origin
            // r1 = r * (m2/M), r2 = -r * (m1/M)
            const r1_ratio = m2 / M;
            const r2_ratio = -m1 / M;

            const p1 = new THREE.Vector3(x * r1_ratio, 0, z * r1_ratio);
            const p2 = new THREE.Vector3(x * r2_ratio, 0, z * r2_ratio);

            bh1.position.copy(p1);
            bh2.position.copy(p2);

            updateTrails(p1, p2);

            // Gravitational Wave Frequency
            // f_GW ~ 2 * f_orbital (dominant harmonic)
            const f_orbital = n / (2 * Math.PI);
            // Higher eccentricities emit at higher harmonics, but we plot the peak
            const f_gw = 2 * f_orbital; // Simplified

            // Calculate strain amplitude (rough proxy for visualization)
            // h ~ (G / c^4) * (m1*m2/r) * ...
            const strain = (1.0 / state.a) * (1.0 + state.e * Math.cos(trueAnomaly));

            // Record History
            state.gwHistory.push({ time: Date.now(), f: f_gw, h: Math.cos(state.meanAnomaly * 2) * strain });
            if (state.gwHistory.length > state.maxHistory) {
                state.gwHistory.shift();
            }
        }

        function calculateSchwarzschildRadius(mass) {
            // R_s = 2GM/c^2, scaled up for VISUAL display only
            return Math.max(0.05, (2 * CONSTANTS.G * mass) / (CONSTANTS.c * CONSTANTS.c) * 30);
        }

        function calculatePhysicalRadius(mass) {
            // R_s = 2GM/c^2, true physical scale for merger detection
            return (2 * CONSTANTS.G * mass) / (CONSTANTS.c * CONSTANTS.c);
        }

        function updateTrails(p1, p2) {
            trailPositions1.push(p1.x, p1.y, p1.z);
            if (trailPositions1.length > maxTrailVertices * 3) {
                trailPositions1.splice(0, 3);
            }
            trailGeometry1.setAttribute('position', new THREE.Float32BufferAttribute(trailPositions1, 3));

            trailPositions2.push(p2.x, p2.y, p2.z);
            if (trailPositions2.length > maxTrailVertices * 3) {
                trailPositions2.splice(0, 3);
            }
            trailGeometry2.setAttribute('position', new THREE.Float32BufferAttribute(trailPositions2, 3));

            // Fading colors
            const colors1 = [];
            const colors2 = [];
            const count1 = trailPositions1.length / 3;
            for (let i = 0; i < count1; i++) {
                const intensity = (i / count1); // fade factor
                colors1.push(1.0 * intensity, 0.6 * intensity, 0.0);
                colors2.push(0.0, 0.6 * intensity, 1.0 * intensity);
            }
            trailGeometry1.setAttribute('color', new THREE.Float32BufferAttribute(colors1, 3));
            trailGeometry2.setAttribute('color', new THREE.Float32BufferAttribute(colors2, 3));
        }

        function drawGWGraph() {
            gwCtx.clearRect(0, 0, gwCanvas.width, gwCanvas.height);

            if (state.gwHistory.length < 2) return;

            // Draw axes
            gwCtx.strokeStyle = 'rgba(255,255,255,0.2)';
            gwCtx.beginPath();
            gwCtx.moveTo(0, gwCanvas.height / 2);
            gwCtx.lineTo(gwCanvas.width, gwCanvas.height / 2);
            gwCtx.stroke();

            // The Strain Graph (Chirp)
            gwCtx.beginPath();
            gwCtx.strokeStyle = 'var(--color-accent)';
            gwCtx.lineWidth = 2;

            // Dynamic scaling based on recent history
            let maxH = 0.01;
            for (let pt of state.gwHistory) {
                if (Math.abs(pt.h) > maxH) maxH = Math.abs(pt.h);
            }

            for (let i = 0; i < state.gwHistory.length; i++) {
                const pt = state.gwHistory[i];
                const x = (i / state.maxHistory) * gwCanvas.width;
                // Map strain to Y, centered
                const y = gwCanvas.height / 2 - (pt.h / maxH) * (gwCanvas.height / 2.5);

                if (i === 0) gwCtx.moveTo(x, y);
                else gwCtx.lineTo(x, y);
            }
            gwCtx.stroke();

            // Frequency overlay text
            const currentF = state.gwHistory[state.gwHistory.length - 1].f;
            ui.currentF.innerText = `${currentF.toFixed(3)} Hz`;
        }

        // --- Initialization & Loop ---

        function initSimulation() {
            state.m1 = parseFloat(ui.m1.value);
            state.m2 = parseFloat(ui.m2.value);
            state.a0 = parseFloat(ui.a0.value);
            state.e0 = parseFloat(ui.e0.value);
            state.timeScale = parseFloat(ui.speed.value);

            state.a = state.a0;
            state.e = state.e0;
            state.meanAnomaly = 0;
            state.isMerged = false;
            state.gwHistory = [];
            trailPositions1 = [];
            trailPositions2 = [];
            trailGeometry1.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
            trailGeometry2.setAttribute('position', new THREE.Float32BufferAttribute([], 3));

            // Restore visibility of individual BHs
            scene.add(bh1);
            scene.add(bh2);
            if (mergedBH) mergedBH.visible = false;

            // Initial BH sizes based on mass
            const r1 = calculateSchwarzschildRadius(state.m1);
            const r2 = calculateSchwarzschildRadius(state.m2);
            bh1.scale.set(r1, r1, r1);
            bh2.scale.set(r2, r2, r2);

            updateUI();
        }

        function updateUI() {
            ui.m1Val.innerText = ui.m1.value;
            ui.m2Val.innerText = ui.m2.value;
            ui.a0Val.innerText = ui.a0.value;
            ui.e0Val.innerText = ui.e0.value;
            ui.speedVal.innerText = ui.speed.value;

            if (!state.isMerged) {
                ui.currentA.innerText = `${state.a.toFixed(3)} AU`;
                ui.currentE.innerText = state.e.toFixed(3);
            } else {
                ui.currentA.innerText = "MERGED";
                ui.currentE.innerText = "MERGED";
            }
        }

        // Event Listeners
        const inputs = [ui.m1, ui.m2, ui.a0, ui.e0];
        inputs.forEach(input => {
            input.addEventListener('input', () => {
                updateUI();
                // We only auto-restart if slider ends? Actually, input fires continuously. 
                // Let's NOT auto-restart on input for performance, wait for change, 
                // but we DO update the UI values.
            });
            input.addEventListener('change', initSimulation);
        });

        ui.speed.addEventListener('input', () => {
            state.timeScale = parseFloat(ui.speed.value);
            ui.speedVal.innerText = ui.speed.value;
        });

        ui.resetBtn.addEventListener('click', initSimulation);

        // Full browser toggle
        document.getElementById('fullBrowserBtn').addEventListener('click', () => {
            document.body.classList.toggle('full-browser');
            setTimeout(onWindowResize, 100);
        });

        function onWindowResize() {
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);

            gwCanvas.width = gwCanvas.parentElement.clientWidth;
            gwCanvas.height = gwCanvas.parentElement.clientHeight;
        }
        window.addEventListener('resize', onWindowResize);

        // Hide loading
        loading.style.opacity = 0;
        setTimeout(() => loading.style.display = 'none', 500);

        // Main Loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            let dt = clock.getDelta();
            if (dt > 0.1) dt = 0.1; // cap

            // Run physics
            const dtScaled = Math.min(dt * state.timeScale * 2.0, 0.1);

            updatePhysics(dtScaled);

            controls.update();

            renderer.render(scene, camera);

            drawGWGraph();
            updateUI();
        }

        initSimulation();
        animate();
    </script>
</body>

</html>